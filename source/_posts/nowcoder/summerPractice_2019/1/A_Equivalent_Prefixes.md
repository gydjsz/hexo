---
title: 2019牛客暑期多校训练营（第一场）A
tags: 
- 2019牛客暑期多校训练营（第一场）
- 单调栈
---

[Equivalent Prefixes](https://ac.nowcoder.com/acm/contest/881/A)

# 题意:
两个数组u和v, 找出最大p,使得两个数组在区间[1,q]中,任意一个子区间的
最小值的下标相同

1. 数组中的数互不相同
2. $多组样例, 数组大小n不超过10^5, 其和不超过5 * 10^5$
3. 输出p

<!--more--> 

```
样例:
2
1 2
2 1

3
2 1 3
3 1 2

5
3 1 5 2 4
5 2 4 3 1

输出:
1
3
4
```

## 解释:

2
1 2
2 1

数组大小n=2
a[] = {1, 2}
b[] = {2, 1}

q = 1
在区间[1, 1]中, a数组最小值为1, 下标1; b数组最小值为2, 下标1.两下标相同

q = 2
在区间[1, 2]中, a数组最小值为1, 下标1; b数组最小值为1, 下标2.两下标不相同
在区间[2, 2]中, a数组最小值为2, 下标2; b数组最小值为1, 下标2, 两下标相同

所以答案为1

---
3
2 1 3
3 1 2

数组大小n=3

q = 1
在区间[1, 1]中, a数组最小值为2, 下标1; b数组最小值为3, 下标1.两下标相同

q = 2
在区间[1, 2]中, a数组最小值为1, 下标2; b数组最小值为1, 下标2.两下标相同
在区间[2, 2]中, a数组最小值为1, 下标2; b数组最小值为1, 下标2.两下标相同


q = 3
在区间[1, 3]中, a数组最小值为1, 下标2; b数组最小值为1, 下标2.两下标相同
在区间[2, 3]中, a数组最小值为1, 下标2; b数组最小值为1, 下标2.两下标相同 
在子区间[1, 1], [2, 2], [3, 3], [1, 2]中最小值下标相同

所以答案为3

---

# 解法:

单调栈: 栈内的元素都保持一个单调性，可能为单调递增，也可能为单调递减。

对于序列:
9 3 7 1 8 

维护单调递增栈:
- 9入栈
=> 9
- 3入栈
9 > 3
9出栈,3入栈
=> 3
- 7入栈
=> 3 7
- 1入栈
3,7出栈, 1入栈
=> 1
- 8入栈
=> 1 8
---

## 思路

+ 由于是区间从1到p,则可以从前往后遍历,分别维护两个数组的单调栈序列
+ 两个单调栈整体单调,而局部也单调,要想子区间也满足最小值下标相同,则
局部单调性要相同,由于出栈表示值较小,入栈表示值较大,
若要局部单调性也相同则出栈和入栈的次序相同,转化一下就是栈变化后的大小相同
+ 若不满足栈变化后大小相同,则退出循环,输出当前位置-1
+ 所有数有入栈和出栈两种情况,所以时间复杂度为O(2*n)=>O(n)

```
5
3 1 5 2 4
5 2 4 3 1

3
       => 1
5

1
       => 2
2

1 5
       => 3
2 4

1 2 
       => 4
2 3

1 2 4
       => 4
1

p = 4
```

# 代码:

```cpp
#include <iostream>
#include <stack>
using namespace std;

const int maxn = 1e5 + 10;
int n;
int a[maxn];
int b[maxn];

int solve() {
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        cin >> b[i];
    }

    //数组a,b的单调栈sa, sb
    stack<int> sa, sb;
    int p = n;
    for (int i = 1; i <= n; i++) {
        //将单调栈中小于a[i]的数弹出,然后将a[i]入栈
        while (!sa.empty() && sa.top() > a[i])  
            sa.pop();
        while (!sb.empty() && sb.top() > b[i])
            sb.pop();

        //如果两个单调栈的大小不同,则不满足任意子区间最小值的下标相同
        if (sa.size() != sb.size()) {
            p = i - 1;
            break;
        }
        sa.push(a[i]);
        sb.push(b[i]);
    }
    cout << p << endl;
    return 0;
}

int main() {
    while (cin >> n) {
        solve();
    }
    return 0;
}
```
