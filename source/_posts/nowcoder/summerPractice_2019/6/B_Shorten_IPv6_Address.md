---
title: 2019牛客暑期多校训练营（第六场）B
tags:
- 2019牛客暑期多校训练营（第六场）
- 模拟题
---

[Shorten IPv6 Address](https://ac.nowcoder.com/acm/contest/886/B)

# 题意

给出ipv6的二进制数字,将其用十六进制表示,并省略字段中的0

1. 至少两个字段组成的连续零字段可以用"::"代替
2. 只能简化一次
3. 字段尽量短, 如果有多个长度一样,则输出字典序最小的一个
4. T组样例, 每组样例一行,包含128位二进制字符串
5. 在一行中输出“Case #x：y”，其中x表示从1开始的案例编号，y表示该测试用例的答案
   
<!--more-->

```
样例:
3
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000010010001101000101011001111000100110101011000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000010010001100000000000000000000000000000000000000000000000001000101011001111000100110101011

输出:
Case #1: ::
Case #2: 0:0:123:4567:89ab::
Case #3: 0:0:123::4567:89ab
```

## 解释
00000000000000000000000000000000000000010010001101000101011001111000100110101011000000000000000000000000000000000000000000000000

转化为16进制为0:0:123:4567:89ab:0:0:0,
(:ACSII码比0大)省略后面3个0,变为
0:0:123:4567:89ab::,字段最短

# 解法

## 思路
1. 先将二进制转化为十六进制
2. 每次删去一连串的0,并保存在数组中
3. 排序,找最短或字典序最小的字符串

## 代码
```cpp
#include <algorithm>
#include <cmath>
#include <iostream>
using namespace std;

const int maxn = 10;
//样例计数
int index;
//存储十六进制数
char a[] = {'0', '1', '2', '3', '4', '5', '6', '7',
            '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

bool cmp(string s1, string s2) {
    if (s1.length() == s2.length())
        return s1 < s2;
    return s1.length() < s2.length();
}

int solve() {
    //128位二进制
    string s;
    cin >> s;
    //转化后的ipv6字符串
    string ip[maxn];
    //每4位二进制转化成1位十六进制后的字符串
    string ss;
    int m = 0, j = 0; //m为4位二进制转化为十进制的数,j为ip的下标
    for (int i = 0; i < s.length(); i++) {
        //将4位二进制转化为十进制
        m += pow(2, (3 - i % 4)) * (s[i] - '0');
        //每1位十六进制存储一次字符,如果不为0,则合并
        if (i % 4 == 3) {
            ss == "0" ? ss = a[m] : ss += a[m];
            m = 0;
        }
        //每4个十六进制存储在ip中
        if (i % 16 == 15) {
            ip[j++] = ss;
            ss = "";
        }
    }

    //存储0所在的left和right下标
    pair<int, int> zero[maxn];
    zero[0].first = -1, zero[0].second = -1;  //表示整个ip
    int k = 1; //zero的下标
    for (int i = 0; i < 8; i++) {
        //如果有连续的ip为0,就加入进zero
        if (ip[i] == "0" && i + 1 < 8 && ip[i + 1] == "0") {
            zero[k].first = i;
            while (ip[i] == "0" && i < 8)
                i++;
            zero[k++].second = i - 1;
        }
    }

    //存储所有缩短ip的情况
    string all[maxn];
    int t = 0;  //all的下标
    for (int i = 0; i < k; i++) {  //遍历所有连续0
        for (int j = 0; j < 8; j++) {  //遍历ip
        //添加":",如果是第一个位置为连续0就要两个":",中间的一个数后面跟一个":",最后的数后面没有":"
            if (j == zero[i].first)
                all[t] += j == 0 ? "::" : ":";
            //除去0
            if (zero[i].first <= j && j <= zero[i].second)
                continue;
            all[t] += ip[j];
            if (j != 7)
                all[t] += ":";
        }
        t++;
    }
    //先按长度排序,再按字典序排序
    sort(all, all + t, cmp);
    cout << "Case #" << ++index << ": " << all[0] << endl;
    return 0;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        solve();
    }
    return 0;
}
```